import logging
from datetime import datetime
from typing import Dict, List, Optional

import coloredlogs
from cognite.client.data_classes import Asset, Sequence, SequenceList
from cognite.well_model import CogniteWellsClient
from cognite.well_model.models import DepthMeasurementIngestion, SequenceSource

from utils import clients
from utils.log_progress import log_progress
from utils.measurements import measured_depth, measurement_columns

coloredlogs.install()
log = logging.getLogger(__name__)


def create_depth_measurement_ingestion(
    wdl: CogniteWellsClient,
    seq: Sequence,
    assets_dict: Dict[int, Asset],
) -> Optional[DepthMeasurementIngestion]:
    wellbore_asset = assets_dict.get(seq.asset_id) if seq.asset_id else None
    if wellbore_asset is None:
        log.warning(f"    Couldn't find wellbore to connect '{seq.external_id}' to.")
        return None
    # Sequences generated by the WSFE will always have the index as the
    # first column. If it isn't a depth, it shouldn't be ingested as a depth
    # measurement.
    depth_column = measured_depth(seq.columns[0])
    if depth_column is None:
        log.warning(f"    Couldn't find MD column for sequence {seq.external_id}")
        return None

    curves = measurement_columns(wdl, seq.columns[1:])
    if len(curves) == 0:
        all_column_external_ids = [c.get("externalId") for c in seq.columns]
        log.warning(
            f"    Sequence {seq.external_id} has no measurement columns. "
            + f"Looked through these columns: {all_column_external_ids}, "
            + "but failed to map them to measurement types."
        )
        return None

    return DepthMeasurementIngestion(
        wellbore_asset_external_id=wellbore_asset.external_id,
        depth_column=depth_column,
        columns=curves,
        source=SequenceSource(
            source_name="OSDU",
            sequence_external_id=seq.external_id,
        ),
    )


def main():
    client, wdl = clients()

    log.info("Retrieving CDF sequences")
    sequences = client.sequences.list(limit=None)
    well_logs: List[Sequence] = SequenceList([x for x in sequences if x.description == "Well Log"])
    log.info(f"Found {len(sequences)} sequences and identified {len(well_logs)} well logs")
    print(well_logs.to_pandas())

    log.info("Retrieving CDF assets to be able to connect sequence.asset_id to asset.external_id")
    asset_ids = list({x.asset_id for x in well_logs})
    assets = client.assets.retrieve_multiple(ids=asset_ids)
    assets_dict = {x.id: x for x in assets}
    log.info(f"Found {len(assets)} assets")

    log.info("Retrieving depth measurements from WDL to prevent redundant work.")
    already_ingested = {
        x.source.sequence_external_id for x in wdl.depth_measurements.list(limit=None)
    }
    log.info(f"Found {len(already_ingested)} depth measurements already in WDL.")
    well_logs = [x for x in well_logs if x.external_id not in already_ingested]

    start_time = datetime.now()
    for i, well_log in enumerate(well_logs):
        progress_str = log_progress(start_time, i, len(well_logs))
        log.info(f"{progress_str} Creating depth measurement ingestion for {well_log.external_id}")
        ingestion = create_depth_measurement_ingestion(wdl, well_log, assets_dict)
        if ingestion is not None:
            try:
                wdl.depth_measurements.ingest([ingestion])
            except Exception as e:
                log.error("    Failed to ingest WDL depth measurements", exc_info=e)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("KeyboardInterrupt")
        exit(0)
